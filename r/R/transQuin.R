#
#  Copyright (C) 2015 - Garvan Institute of Medical Research
#
#  Ted Wong, Bioinformatic Software Engineer at Garvan Institute.
#
#  Credits: RUV source package (http://bioconductor.org/packages/release/bioc/html/RUVSeq.html)
#

#
# RNA normalization by RUVg (Remove Unwanted Variation)
#

.RUVgNorm <- function(x, cIdx, round=TRUE, k=1, epsilon=1, tolerance=1e-8, isLog=FALSE)
{
    # Log-linear GLM
    Y <- t(log(x+epsilon))
    
    # Scale to a zero-mean matrix
    Ycenter <- apply(Y, 2, function(x) scale(x, center = TRUE, scale=FALSE))
    
    m <- nrow(Y)
    n <- ncol(Y)
    
    # Perform a SVD decomposition for the control genes
    svdWa <- svd(Ycenter[, cIdx])
    
    drop <- 0
    first <- 1 + drop
    k <- min(k, max(which(svdWa$d > tolerance)))
    
    # Extract the first k principal components    
    W <- svdWa$u[, (first:k), drop = FALSE]
    
    # Estimate the parameter for the unwanted variation    
    alpha <- solve(t(W) %*% W) %*% t(W) %*% Y
    
    # Estimate the biological variation
    correctedY <- Y - W %*% alpha
    
    if (!isLog)
    {
        if(round) {
            correctedY <- round(exp(correctedY) - epsilon)
            correctedY[correctedY<0] <- 0
        } else {
            correctedY <- exp(correctedY) - epsilon
        }
    }
    
    colnames(W) <- paste("W", seq(1, ncol(W)), sep="_")
    
    r <- list(W = W, normalizedCounts = t(correctedY))
    r
}

#
# Apply RNA normalization to a count matrix. The following modes are supported:
#
#    'RUV' -> Remove Unwanted Variation (http://bioconductor.org/packages/release/bioc/html/RUVSeq.html)
#

TransNorm <- function(x, m=loadMixture(), round=TRUE, k=1, epsilon=1, tolerance=1e-8, isLog=FALSE)
{
    # Known control genes
    known <- m$genes$ID
    
    # The control genes detected in the experiment
    detected <- rownames(x) %in% known    
    
    r <- .RUVgNorm(x, detected)
    r
}

#
# Analyze a resulting object generated by DESeq2
#

.analyzeDESeq2 <- function(r, mix)
{
    # List of known sequins
    known <- as.character(mix$genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Level of significance
    p <- 0.1
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
    print(sprintf("Detected %d known sequins", length(known)))	
    print(sprintf("Detected %d experimental genes", length(rownames(r))))
    print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
    
    #
    # Create a data-frame for all sequins defined, whether it's detected. The fold-changes are
    # on the logarithmic scale.
    #
    
    d <- data.frame(ID=known,
                    known=rep(NaN, length(known)),
                    measured=rep(NaN, length(known)),
                    padj=rep(NaN, length(known)),
                    classify=rep(NaN, length(known)),
                    expressed=rep(NaN, length(known)))
    
    #
    # In this context, NaN refers to undetected sequins while Na refers to detected
    # but untested sequins
    #
    
    for (id in known)
    {
        d[d$ID==id,]$known <- mix$genes[mix$genes$ID==id,]$LogFold
    }
    
    for (id in rownames(r))
    {
        d[d$ID==id,]$padj      <- r[id,]$padj
        d[d$ID==id,]$measured  <- r[id,]$log2FoldChange
        d[d$ID==id,]$expressed <- ifelse(r[id,]$padj <= p, 'T', 'F')
    }
    
    # Sort by adjusted p-values just that the expressed genes are at the front
    d <- d[with(d, order(padj)),]
    
    # Fit a simple-linear regression model on the filtered sequins
    m <- lm(known ~ measured, d[is.finite(d$measured),])
    
    r     <- cor(as.numeric(d$known), as.numeric(d$measured))
    r2    <- summary(m)$r.squared
    slope <- coef(m)["known"]
    
    #
    # Check for negatives and positives. By definition, anything that has a fold-change other than
    # 1 at the gene level should be differential expressed.
    #
    
    plotScatter(d$known, d$measured, d$ID, isLog=TRUE)
    
    r <- d
    class(r) <- c("TransDiff")
    r 
}

#
# Analyze a resulting object generated by edgeR
#

.analyzeEdgeR <- function(r, mix)
{
    # List of known sequins
    known <- as.character(mix$genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
    print(sprintf("Detected %d known sequins", length(known)))	
    print(sprintf("Detected %d experimental genes", length(rownames(r))))
    print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
    
    # Create a data-frame for each sequin defined, whether it's detected
    d <- data.frame(ID=known, known=rep(NaN, length(known)), measured=rep(NaN, length(known)))
    
    # For each sequin detected, calculate it's known and measured log-fold change
    for (id in rownames(r))
    {
        d[d$ID==id,]$known    <- mix$genes[mix$genes$ID==id,]$LogFold
        d[d$ID==id,]$measured <- r$table[id,]$logFC
    }
    
    #
    # Fit a linear model for sequins that are detected in the experiment.
    #
    
    d <- d[is.finite(d$measured),]
    
    # Fit a simple-linear regression model
    m <- lm(d$known ~ d$measured)
    
    # Pearson's correlation
    r <- cor(as.numeric(d$known), as.numeric(d$measured))
    
    # Coefficients of determination
    r2 <- summary(m)$r.squared
    
    # Regression slope
    slope <- coef(m)["known"]
    
    plotScatter(d$known, d$measured, d$ID, isLog=TRUE)
    
    r <- d
    class(r) <- c("TransDiff")
    r 
}

#
# Compare the empirical differential results with expectation
#

TransDiff <- function(r, m=loadMixture())
{
    if (class(r) == 'DESeqResults')
    {
        print('Analyzing DESeq2 object' )
        .analyzeDESeq2(r, m)
    }
    else if (class(r)[1] == 'DGEExact')
    {
        print('Analyzing edgeR' )
        .analyzeEdgeR(r, m)
    }
    else
    {
        stop('Unknown input. The input must be a result object from DESeq2 or EdgeR')
    }    
}