#
#  Copyright (C) 2015 - Garvan Institute of Medical Research
#
#  Ted Wong, Bioinformatic Software Engineer at Garvan Institute.
#

.filter <- function(d, mix)
{
    # List of known sequins
    known <- as.character(mix$genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(d) %in% known
    
    d <- d[detected,]
    d
}

#
# Apply RNA normalization to a count matrix. The following modes are supported:
#
#    'RUV' -> Remove Unwanted Variation (http://bioconductor.org/packages/release/bioc/html/RUVSeq.html)
#

TransNorm <- function(d, mix=loadMixture(), round=TRUE, k=1, epsilon=1, tolerance=1e-8, isLog=FALSE)
{
    #
    # The RUVg package doesn't address the positive control genes. Instead it writes: "Note that one
    # can relax the negative control gene assumption by requiring insread the identification of a set
    # of positive and negative controls, with a .... One can then use the centered counts .. for
    # normalization purposes."
    #
    # Here, we'll scale the counts for all the positve control genes.
    #
    
    # Filter out only to sequins
    f <- d <- .filter(d, mix)
    
    for (id in rownames(f))
    {
        # What's the expected fold-change for this sequin?
        expect <- fold(sequin(id, mix))
        
        f[id,]$B1 <- f[id,]$B1 / expect
        f[id,]$B2 <- f[id,]$B2 / expect
        f[id,]$B3 <- f[id,]$B3 / expect
    }
    
    r <- .RUVaNorm(f, rownames(f))
    r
}

#
# Analyze a resulting object generated by DESeq2
#

.analyzeDESeq2 <- function(r, mix, logFC=0)
{
    # List of known sequins
    known <- as.character(mix$genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
    # Level of significance
    p <- 0.1
    
    print(sprintf("Detected %d known sequins", length(known)))
    print(sprintf("Detected %d experimental genes", length(rownames(r))))
    print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
    
    #
    # Create a data-frame for all sequins defined, whether it's detected. The fold-changes are
    # on the logarithmic scale.
    #
    #
    # In this context, NaN refers to undetected sequins while NA refers to detected
    # but untested sequins
    #
    
    d <- data.frame(known=rep(NaN, length(known)),
                    measured=rep(NaN, length(known)),
                    padj=rep(NaN, length(known)),
                    expressed=rep(NaN, length(known)),
                    class=rep(NaN, length(known)))
    rownames(d) <- known
    
    for (id in known)
    {
        d[id,]$known <- mix$genes[mix$genes$ID==id,]$LogFold
    }
    
    for (id in rownames(r))
    {
        d[id,]$padj      <- r[id,]$padj
        d[id,]$measured  <- r[id,]$log2FoldChange
        d[id,]$expressed <- ifelse(r[id,]$padj <= p, 'T', 'F')
    }
    
    # Sort by adjusted p-values so that the expressed genes are at the front
    d <- d[with(d, order(padj)),]
    
    # Fit a simple-linear regression model on the filtered sequins
    m <- lm(known ~ measured, d[is.finite(d$measured),])
    
    r     <- cor(as.numeric(d$known), as.numeric(d$measured))
    r2    <- summary(m)$r.squared
    slope <- coef(m)["known"]
    
    #
    # Classify each sequin. By default, anything that has a fold-change other than logFC=0 at the
    # gene level is expected to be differential expressed. The following classes are possible:
    #
    #    FN (false negative): genes that have fold-change with at most logFC and expressed
    #    TP (true positive):  genes that have fold-change with more than logFC and expressed
    #    FP (false positive): genes that have fold-change with at most logFC and not expressed
    #    TN (true negative):  genes that have fold-change with more than logFC and not expressed
    #
    
    for (id in rownames(d))
    {
        if      (is.na(d[id,]$padj))  { d[id,]$class <- NA  }
        else if (is.nan(d[id,]$padj)) { d[id,]$class <- NaN }
        else if (d[id,]$padj <= p)
        {
            # Differential expressed sequin
            d[id,]$class <- ifelse(abs(d[id,]$known) <= logFC, 'FP', 'TP')
        }
        else
        {
            # Non-differential expressed sequin
            d[id,]$class <- ifelse(abs(d[id,]$known) <= logFC, 'TN', 'FN')            
        }
    }
    
    p <- d[!is.nan(d$padj),]
    p <- d[!is.na(d$padj),]
    
    print(sprintf("Detected %d false positives", nrow(p[p$class=='FP',])))
    print(sprintf("Detected %d true positives",  nrow(p[p$class=='TP',])))
    print(sprintf("Detected %d true negatives",  nrow(p[p$class=='TN',])))
    print(sprintf("Detected %d false negatives", nrow(p[p$class=='FN',])))    
    
    plotScatter(p$known, p$measured, rownames(p), isLog=TRUE)
    
    r <- list(data=d, r=r, r2=r2, slope=slope, m=m)
    class(r) <- c("TransDiff")
    r
}

#
# Analyze a resulting object generated by edgeR
#

.analyzeEdgeR <- function(r, mix)
{
    # List of known sequins
    known <- as.character(mix$genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
    print(sprintf("Detected %d known sequins", length(known)))	
    print(sprintf("Detected %d experimental genes", length(rownames(r))))
    print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
    
    # Create a data-frame for each sequin defined, whether it's detected
    d <- data.frame(ID=known, known=rep(NaN, length(known)), measured=rep(NaN, length(known)))
    
    # For each sequin detected, calculate it's known and measured log-fold change
    for (id in rownames(r))
    {
        d[d$ID==id,]$known    <- mix$genes[mix$genes$ID==id,]$LogFold
        d[d$ID==id,]$measured <- r$table[id,]$logFC
    }
    
    #
    # Fit a linear model for sequins that are detected in the experiment.
    #
    
    d <- d[is.finite(d$measured),]
    
    # Fit a simple-linear regression model
    m <- lm(d$known ~ d$measured)
    
    # Pearson's correlation
    r <- cor(as.numeric(d$known), as.numeric(d$measured))
    
    # Coefficients of determination
    r2 <- summary(m)$r.squared
    
    # Regression slope
    slope <- coef(m)["known"]
    
    plotScatter(d$known, d$measured, d$ID, isLog=TRUE)
    
    r <- d
    class(r) <- c("TransDiff")
    r 
}

#
# Compare the empirical differential results with expectation
#

TransDiff <- function(r, m=loadMixture())
{
    if (class(r) == 'DESeqResults')
    {
        print('Analyzing DESeq2 object' )
        .analyzeDESeq2(r, m)
    }
    else if (class(r)[1] == 'DGEExact')
    {
        print('Analyzing edgeR' )
        .analyzeEdgeR(r, m)
    }
    else
    {
        stop('Unknown input. The input must be a result object from DESeq2 or EdgeR')
    }    
}