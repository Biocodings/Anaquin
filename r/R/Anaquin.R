#  Copyright (C) 2015 - Garvan Institute of Medical Research
#
#  Anaquin is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  Anaquin is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Anaquin If not, see <http://www.gnu.org/licenses/>.

library('edgeR')
library("DESeq2")
library("Rsamtools")
library("GenomicFeatures")
library("GenomicAlignments")

#
# Given a list of alignment files, this function computes a count matrix for it.
#

AQ_Prepare <- function(files, meta)
{
	bams <- BamFileList(files)

	# Read in the gene model which will be used for counting reads
	model <- makeTranscriptDbFromGFF("/home/tedwon/Sources/QA/data/trans/ATR001.v032.gtf", format='gtf')

	# Load experimental metadata for the samples
	meta <- read.csv(file.path('', meta), row.names=1)

	# Produces a GRangesList of all the exons grouped by gene
	genes <- exonsBy(model, by="gene")

	# Fix the duplicate keysâ€¦
	names(bams) <- c("A1.bam", "A2.bam", "A3.bam", "B1.bam", "B2.bam", "B3.bam")

	se <- summarizeOverlaps(features=genes, reads=bams, mode="Union", singleEnd=FALSE, ignore.strand=TRUE, fragments=TRUE)

	# The colData slot is so far empty, should contain all the metadata
	colData(se) <- DataFrame(meta)
	
	se
}

IsoformsToGenes <- function(trans)
{
    trans <- as.character(trans)
    genes <- substr(as.character(trans), 1, nchar(trans)-2)
    genes
}

#
# Load the mixture into an R object that can be used with other Anaquin functions
#

AQ_Mixture <- function()
{
    mix <- read.csv(url('https://s3.amazonaws.com/anaquin/mixtures/MTR004.v013.csv'), sep='\t')

    #ref <- read.csv(url('http://anaquin.org/downloads/RNA_1.gtf'))
    #ref <- makeTranscriptDbFromGFF(file = '/Users/tedwong/Sources/QA/data/trans/RNA.v1.gtf', format = "gtf")
    #ref <- unique(IsoformsToGenes(transcripts(ref)$tx_name))
    
    # Eg: R1_1 for R1_1_1 and R1_1_2    
    mix$GeneID <- IsoformsToGenes(mix$ID)
    
    # Genes that are defined in the mixture
    geneIDs <- unique(mix$GeneID)

    # Genes that are defined in reference but not reference and therfore must be ignored as there's no concentration
    #ignored <- ref[!(ref %in% geneIDs)]    
    #combined <- c(geneIDs, ignored)
    
    g <- data.frame(ID=geneIDs,
                    A=rep(0, length(geneIDs)),
                    B=rep(0, length(geneIDs)),
                    Fold=rep(0, length(geneIDs)),
                    LogFold = rep(0, length(geneIDs)))

	#
	# Calculate the expected log-fold between mixture A and B
	#
    
    for (id in geneIDs)
    {
        seqs <- mix[mix$GeneID == id,]
        
        #
        # Calculate the expected abundance. We assume the following format:
		#
		#      ID     Length     Mix A      Mix B
		#    -------------------------------------
		#     R1_11    703     161.13281    5.0354
		#
		# 
		# We shouldn't assume anything for the column names.
		#
		
	    g[g$ID == id,]$A <- sum(seqs[,3])
        g[g$ID == id,]$B <- sum(seqs[,4])

        #
        # Calculate the expected fold change
        #
        
        g[g$ID == id,]$Fold    <- g[g$ID == id,]$B / g[g$ID == id,]$A
        g[g$ID == id,]$LogFold <- log2(g[g$ID == id,]$Fold)
    }
    
    #
    # We simply can't assume that sequins defined in the mixture and reference are identical.
    # Here, we find out those sequins that are not defined in the mixture.
    #
    
    #for (id in ignored)
    #{
    #    g[g$ID == id,]$a       <- 'NA'
    #    g[g$ID == id,]$b       <- 'NA'
    #    g[g$ID == id,]$fold    <- 'NA'
    #    g[g$ID == id,]$logFold <- 'NA'
    #}
    
    # Prefer not to have it as factor variable
    g$ID <- as.character(g$ID)
    
    # Sort by ID so that it'll more easier interpreted
    g <- g[with(g, order(ID)),]
    
    r <- list('Data'=data.frame(mix), 'Genes'=g)
    class(r) <- c("Mixture")
    r
}

#
# Analyze a resulting object generated by DESeq2
#

AQ_DESeq2 <- function(r, mix)
{
    # List of known sequins
    known <- as.character(mix$Genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
	print(sprintf("Detected %d known sequins", length(known)))	
	print(sprintf("Detected %d experimental genes", length(rownames(r))))
	print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
	
    # Create a data-frame for each sequin defined, whether it's detected
    d <- data.frame(ID=known, Known=rep(NaN, length(known)), Measured=rep(NaN, length(known)))

    # For each sequin detected, calculate it's known and measured log-fold change
    for (id in rownames(r))
    {
        d[d$ID==id,]$Known    <- mix$Genes[mix$Genes$ID==id,]$LogFold
        d[d$ID==id,]$Measured <- r[id,]$log2FoldChange
    }
	
    #
    # Fit a linear model for sequins that are detected in the experiment.
    #
    
    d <- d[is.finite(d$Measured),]

	known    <- d$Known
	measured <- d$Measured

    # Fit a simple-linear regression model
    m <- lm(known ~ measured)
    
    # Pearson's correlation
    r <- cor(as.numeric(known), as.numeric(measured))
    
    # Coefficients of determination
    r2 <- summary(m)$r.squared
    
    # Regression slope
    slope <- coef(m)["known"]
    
    # Generate a linear plot of the relationship
    plot(known, measured)

    r <- list(data=data.frame(known, measured))
    class(r) <- c("Anaquin")
    r 
}

#
# Analyze a resulting object generated by edgeR
#

AQ_EdgeR <- function(r, mix)
{
    # List of known sequins
    known <- as.character(mix$Genes$ID)
    
    # Genes that have been detected in the experiment    
    detected <- rownames(r) %in% known
    
    # Filter out to only the rows with sequins
    r <- r[detected,]
    
	print(sprintf("Detected %d known sequins", length(known)))	
	print(sprintf("Detected %d experimental genes", length(rownames(r))))
	print(sprintf("%d sequins failed to detect", length(known) - length(rownames(r))))
	
    # Create a data-frame for each sequin defined, whether it's detected
    d <- data.frame(ID=known, Known=rep(NaN, length(known)), Measured=rep(NaN, length(known)))

    # For each sequin detected, calculate it's known and measured log-fold change
    for (id in rownames(r))
    {
        d[d$ID==id,]$Known    <- mix$Genes[mix$Genes$ID==id,]$LogFold
        d[d$ID==id,]$Measured <- r$table[id,]$logFC
    }

    #
    # Fit a linear model for sequins that are detected in the experiment.
    #
    
    d <- d[is.finite(d$Measured),]

	known    <- d$Known
	measured <- d$Measured

    # Fit a simple-linear regression model
    m <- lm(known ~ measured)
    
    # Pearson's correlation
    r <- cor(as.numeric(known), as.numeric(measured))
    
    # Coefficients of determination
    r2 <- summary(m)$r.squared
    
    # Regression slope
    slope <- coef(m)["known"]
    
    # Generate a linear plot of the relationship
    plot(known, measured)

    r <- list(data=data.frame(known, measured))
    class(r) <- c("Anaquin")
    r 
}

Anaquin <- function(r, m=AQ_Mixture())
{
    if (class(r) == 'DESeqResults')
    {
		print('Analyzing DESeq2 object' )
        AQ_DESeq2(r, m)
    }
    else if (class(r)[1] == 'DGEExact')
    {
		print('Analyzing edgeR' )
        AQ_EdgeR(r, m)
    }
    else
    {
        stop('Unknown input. The input must be a result object from DESeq2 or EdgeR')
    }    
}
