#ifndef GI_M_ASSEMBLY_HPP
#define GI_M_ASSEMBLY_HPP

#include "analyzer.hpp"
#include "data/tokens.hpp"
#include "meta/histogram.h"
#include "parsers/parser_fa.hpp"

namespace Spike
{
    struct DNAsssembly
    {
        template <typename T> struct Stats
        {
            BasePair min, max;
            BasePair mean, sum;
            BasePair N20, N50, N80;

            // List of assembled contigs not in any specifc order
            std::vector<T> contigs;
        };

        template <typename T = DNAsssembly::Stats<Contig>, typename C = Contig> static T parse(const std::string &file, std::function<void (const C&)> f)
        {
            T stats;
            Histogram h;

            /*
             * Read a file of assembled contigs. The file is assumed to be in a FA format.
             */
            
            ParserFA::parse(file, [&](const FALine &l, const ParserProgress &)
                            {
                                C c;

                                c.id = l.id;

                                // Sequence of the config
                                c.seq = l.seq;

                                // The histogram needs the length of the sequence
                                h.insert(l.seq.length());

                                // Allows to apply operations on a specific assembler
                                f(c);

                                stats.contigs.push_back(c);
                            });
            
            // This is copied from printContiguityStats() in Histogram.h of the Abyss source code.
            h = h.trimLow(500);
            
            /*
             * Reference: https://github.com/bcgsc/abyss/blob/e58e5a6666e0de0e6bdc15c81fe488f5d83085d1/Common/Histogram.h
             */
            
            stats.sum  = h.sum();
            stats.N50  = h.n50();
            stats.min  = h.minimum();
            stats.max  = h.maximum();
            stats.mean = h.expectedValue();
            stats.N80  = h.weightedPercentile(1 - 0.8);
            stats.N20  = h.weightedPercentile(1 - 0.2);
            
            return stats;
        }
    };
    
    struct Velvet
    {
        template <typename Stats, typename C> static Stats parse(const std::string &file)
        {
            Stats stats;
            
            /*
             * Read coverage from the contig file. The format looks like:
             *
             *      >NODE_77460_length_31_cov_1.129032
             */
            
            std::vector<std::string> tokens;
            
            return DNAsssembly::parse<Stats, C>(file, [&](const C &node)
            {
                C copy = node;
                Tokens::split(node.id, "_", tokens);

                // Parse the k-mer coverage
                copy.k_cov = stod(tokens[tokens.size() - 1]);
            });
        }
    };

    struct MAssembly
    {
        struct AlignedContig : public Contig
        {
            // The sequin that the node has been aligned to, empty if not aligned
            std::string sequin;
        };
        
        struct Stats : public DNAsssembly::Stats<AlignedContig>
        {
            // Empty Implementation
        };
    
        struct Options : public SingleMixtureOptions
        {
            // An optional PSL file generated by BLAST
            std::string blast;
        };

        static Stats analyze(const std::string &file, const Options &options = Options());
    };
}

#endif