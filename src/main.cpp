#include <map>
#include <ctime>
#include <iostream>
#include <unistd.h>
#include <getopt.h>
#include <execinfo.h>

#include "rna/r_diffs.hpp"
#include "rna/r_align.hpp"
#include "rna/r_assembly.hpp"
#include "rna/r_abundance.hpp"

#include "var/v_align.hpp"
#include "var/v_variant.hpp"

#include "meta/m_blast.hpp"
#include "meta/m_diffs.hpp"
#include "meta/m_assembly.hpp"

#include "ladder/l_diffs.hpp"
#include "ladder/l_correct.hpp"

#include "fusion/f_fusion.hpp"

#include "parsers/parser_csv.hpp"
#include "parsers/parser_sequins.hpp"

#include "writers/file_writer.hpp"
#include "writers/terminal_writer.hpp"

#define CATCH_CONFIG_RUNNER
#include <catch.hpp>

typedef int Mode;
typedef int Command;

typedef std::string OptionName;
typedef std::string OptionValue;

#define CMD_CMD    'c'
#define CMD_VER    'v'
#define CMD_TEST   't'
#define CMD_RNA    265
#define CMD_VAR    266
#define CMD_META   267
#define CMD_LADDER 268
#define CMD_FUSION 269
#define CMD_FETAL  270
#define CMD_CANCER 271
#define CMD_STRUCT 272
#define CMD_CLINIC 273

#define MODE_BLAST     281
#define MODE_ALIGN     283
#define MODE_ASSEMBLY  284
#define MODE_ABUNDANCE 285
#define MODE_DIFFS     286
#define MODE_VARIATION 287
#define MODE_CORRECT   289
#define MODE_MIXTURE   290
#define MODE_FUSION    291

#define OPT_MIN     321
#define OPT_MAX     322
#define OPT_LOS     323
#define OPT_OUTPUT  324
#define OPT_REF     325
#define OPT_MIXTURE 326
#define OPT_FILTER  327
#define OPT_THREAD  328
#define OPT_MODE    329
#define OPT_PSL_1   330
#define OPT_PSL_2   331

using namespace Anaquin;

void handler(int sig)
{
    void *array[10];
    size_t size;
    
    // get void*'s for all entries on the stack
    size = backtrace(array, 10);
    
    // print out all the frames to stderr
    fprintf(stderr, "Error: signal %d:\n", sig);
    backtrace_symbols_fd(array, size, STDERR_FILENO);
    exit(1);
}

struct InvalidCommandException : public std::exception
{
    InvalidCommandException(const std::string &data) : data(data) {}

    // The exact meaning is context-specific
    std::string data;
};

/*
 * The type of the argument is invalid, the expected type is integer. For example, giving
 * "ABCD" as the number of threads.
 */

struct InvalidIntegerError : public InvalidCommandException
{
    InvalidIntegerError(const std::string &arg) : InvalidCommandException(arg) {}
};

// An option is being given more than once
struct RepeatOptionError : public InvalidCommandException
{
    RepeatOptionError(const std::string &opt) : InvalidCommandException(opt) {}
};

/*
 * The type of the argument is valid, but it's not one of the possible values. The
 * most common scenario is specifying a command.
 */

struct InvalidValueError : public std::exception
{
    typedef std::set<std::string> Ranges;
    
    InvalidValueError(const std::string &value, const Ranges &ranges)
            : value(value), ranges(ranges) {}
    
    const Ranges ranges;
    const std::string value;
};

struct MissingMixtureError   : public std::exception {};
struct MissingReferenceError : public std::exception {};

struct InvalidFilterError : public std::runtime_error
{
    InvalidFilterError(const std::string &msg) : std::runtime_error(msg) {}
};

/*
 * Variables used in argument parsing
 */

struct Parsing
{
    // The path that output files are written
    std::string output = "anaquin_out";
    
    // PSL alignment for the mixture A generated by BLAST
    std::string pA;
    
    // PSL alignment for the mixtuee B generated by BLAST
    std::string pB;
    
    // Number of threads
    unsigned threads = 1;
    
    // Custom minmium concentration
    double min = 0;
    
    // Custom maximum concentration
    double max = std::numeric_limits<double>::max();

    // Custom sensivitiy
    double los;

    // Custom reference file
    std::string ref;
    
    // Custom mixture file
    std::string mix;
    
    // The sequins that have been filtered
    std::set<SequinID> filters;

    int cmd  = 0;
    int mode = 0;

    // The first operand for the command
    std::string opt1;

    // The second operand for the command
    std::string opt2;
};

Parsing _p;

/*
 * Defines the possible commands
 */

static std::map<std::string, Command> _cmds =
{
    { "rna",    CMD_RNA    },
    { "var",    CMD_VAR    },
    { "meta",   CMD_META   },
    { "ladder", CMD_LADDER },
    { "cancer", CMD_CANCER },
    { "fusion", CMD_FUSION },
    { "clinic", CMD_CLINIC },
};

typedef std::set<Mode> SupportedModes;

/*
 * Define the possible modes for each command
 */

const SupportedModes l_modes = SupportedModes { MODE_CORRECT, MODE_DIFFS };

static std::map<Command, SupportedModes> _modes =
{
    { CMD_LADDER, l_modes },
};

/*
 * Argument options
 */

static const char *short_options = "";

static const struct option long_options[] =
{
    { "v",      no_argument, 0, CMD_VER  },
    { "verson", no_argument, 0, CMD_VER  },
    { "t",      no_argument, 0, CMD_TEST },
    { "test",   no_argument, 0, CMD_TEST },

    { "c",       required_argument, 0, CMD_CMD },
    { "command", required_argument, 0, CMD_CMD },

    { "min",     required_argument, 0, OPT_MIN },
    { "max",     required_argument, 0, OPT_MAX },

    { "p1",      required_argument, 0, OPT_PSL_1 },
    { "p2",      required_argument, 0, OPT_PSL_2 },

    { "los",     required_argument, 0, OPT_LOS },

    { "r",       required_argument, 0, OPT_REF },
    { "ref",     required_argument, 0, OPT_REF },

    { "t",       required_argument, 0, OPT_THREAD },
    { "threads", required_argument, 0, OPT_THREAD },

    { "m",       required_argument, 0, OPT_MIXTURE },
    { "mix",     required_argument, 0, OPT_MIXTURE },
    { "mixture", required_argument, 0, OPT_MIXTURE },

    { "p",       required_argument, 0, OPT_MODE },
    { "mode",    required_argument, 0, OPT_MODE },

    { "o",       required_argument, 0, OPT_OUTPUT  },
    { "output",  required_argument, 0, OPT_OUTPUT  },

    { "f",        required_argument, 0, OPT_FILTER },
    { "filter",   required_argument, 0, OPT_FILTER },

    { "blast", required_argument, 0, MODE_BLAST },

    {0, 0, 0, 0 }
};

static void printUsage()
{
    extern std::string Manual();
    std::cout << Manual() << std::endl;
}

static void printVersion()
{
    extern float ChromoVersion();
    extern float MixtureVersion();

    // Most likely it's chrT
    extern FileName ChromoName();
    
    std::cout << "Version 1.0. Garvan Institute of Medical Research, 2015." << std::endl;
    std::cout << std::endl;
    std::cout << "Chromosome: " << ChromoName() << " version " << ChromoVersion() << std::endl;
    std::cout << "Mixture: version " << MixtureVersion() << std::endl;
}

// Print a file of mixture A and B
void print(Reader &r)
{
    /*
     * Format: <ID, Mix A, Mix B>
     */

    std::string l;
    
    // Skip the first line
    r.nextLine(l);

    std::cout << "ID\tMix A\tMix B" << std::endl;

    while (r.nextLine(l))
    {
        if (l == "\r" || l == "\n" || l == "\r\n")
        {
            continue;
        }

        std::vector<std::string> tokens;
        Tokens::split(l, "\t", tokens);

        std::cout << tokens[0] << "\t" << tokens[2] << "\t" << tokens[3] << std::endl;
    }
}

static void printMixture(const std::string &file)
{
    Reader r(file, String);
    print(r);
}

template <typename Mixture> void applyMix(Mixture mix)
{
    // The mixture is assumed to be a valid path, if defined
    if (_p.mix.empty())
    {
        throw MissingMixtureError();
    }
    
    std::cout << "Mixture file: "   << _p.mix << std::endl;
    mix(Reader(_p.mix));
}

template <typename Reference> void applyRef(Reference ref)
{
    // The reference is assumed to be a valid path, if defined
    if (_p.ref.empty())
    {
        throw MissingReferenceError();
    }

    std::cout << "Reference file: " << _p.ref << std::endl;
    ref(Reader(_p.ref));
}

// Read sequins from a file, one per line. The identifiers must match.
static void readFilters(const std::string &file)
{
    Reader r(file);
    std::string line;
    
    // We'll use it to compare the sequins
    const auto &s = Standard::instance();

    while (r.nextLine(line))
    {
        switch (_p.cmd)
        {
            case CMD_FUSION: { break; }
            case CMD_LADDER: { break; }

            case CMD_RNA:
            {
                assert(s.r_seqs_A.size() == s.r_seqs_B.size());

                if (!s.r_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for RNA: " + line);
                }
                
                _p.filters.insert(line);
                break;
            }

            case CMD_VAR:
            {
                assert(s.d_seqs_A.size() == s.d_seqs_B.size());
                
                if (!s.d_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for DNA: " + line);
                }
                
                _p.filters.insert(line);
                break;
            }

            case CMD_META:
            {
                assert(s.m_seqs_A.size() == s.m_seqs_B.size());

                if (!s.m_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for metagenomics: " + line);
                }

                _p.filters.insert(line);
                break;
            }

            default: { assert(false); }
        }
    }

    if (_p.filters.empty())
    {
        throw InvalidFilterError("No sequin found in: " + file);
    }
}

template <typename Analyzer, typename F> void analyzeF(F f, typename Analyzer::Options o)
{
    const auto path = _p.output;

    std::cout << "Path: " << path << std::endl;

#ifndef DEBUG
    o.writer   = std::shared_ptr<FileWriter>(new FileWriter(path));
    o.logger   = std::shared_ptr<FileWriter>(new FileWriter(path));
    o.terminal = std::shared_ptr<TerminalWriter>(new TerminalWriter());
    o.logger->open("anaquin.log");
#endif

    std::cout << "-----------------------------------------" << std::endl;
    std::cout << "------------- Sequin Analysis -----------" << std::endl;
    std::cout << "-----------------------------------------" << std::endl << std::endl;
    
    for (const auto &filter : (o.filters = _p.filters))
    {
        std::cout << "Filter: " << filter << std::endl;
    }
    
    std::clock_t begin = std::clock();
    
    f(o);
    
    std::clock_t end = std::clock();
    const double elapsed = double(end - begin) / CLOCKS_PER_SEC;
    std::cout << "Completed. Elpased: " << elapsed << " seconds" << std::endl;

#ifndef DEBUG
    o.logger->close();
#endif
}

// Analyze for a single-sample input
template <typename Analyzer> void analyze(const std::string &file, typename Analyzer::Options o = typename Analyzer::Options())
{
    return analyzeF<Analyzer>([&](const typename Analyzer::Options &o) { Analyzer::analyze(file, o); }, o);
}

// Analyze for two-samples input
template <typename Analyzer> void analyze(const std::string &f1, const std::string &f2, typename Analyzer::Options o = typename Analyzer::Options())
{
    return analyzeF<Analyzer>([&](const typename Analyzer::Options &o) { Analyzer::analyze(f1, f2, o); }, o);
}

template <typename Options> static Options detect(const std::string &file)
{
    const bool found_gene = file.find("gene") != std::string::npos;
    const bool found_isoform = file.find("isoform") != std::string::npos;

    Options o;
    
    if (found_gene && !found_isoform)
    {
        std::cout << "Calculating for the genes" << std::endl;
        o.level = RNALevel::Gene;
    }
    else if (!found_gene && found_isoform)
    {
        std::cout << "Calcualting for the isoforms" << std::endl;
        o.level = RNALevel::Isoform;
    }
    else
    {
        throw std::runtime_error("Unknown type. Have you specified the level?");
    }

    return o;
}

void parse(int argc, char ** argv)
{
    auto &cmd  = _p.cmd;
    auto &mode = _p.mode;
    
    _p = Parsing();

    if (argc <= 1)
    {
        printUsage();
    }

    int next, index;

#ifdef UNIT_TESTING
    optind = optreset = 1;
#endif

    /*
     * Reconstruct the overall command
     */
    
    std::string command;
    
    for (int i = 0; i < argc; i++)
    {
        command += std::string(argv[i]) + " ";
    }

    assert(!command.empty());

    // Attempt to parse and store a floating point from string
    auto parseDouble = [&](const std::string &str, double &r)
    {
        assert(next);
        
        try
        {
            r = stof(str);
        }
        catch (...)
        {
            throw std::runtime_error("ddddd");
        }
    };
    
    // Attempt to parse and store an integer from string
    auto parseInt = [&](const std::string &str, unsigned &r)
    {
        assert(next);
        
        try
        {
            r = stoi(str);
        }
        catch (...)
        {
            throw std::runtime_error("eeee");
        }
    };
    
    auto checkFile = [&](const std::string &file)
    {
        if (!std::ifstream(file).good())
        {
            throw InvalidFileError(file);
        }
    };

    while ((next = getopt_long_only(argc, argv, short_options, long_options, &index)) != -1)
    {
        const auto &arg = argv[index];

        switch (next)
        {
            case OPT_REF:     { checkFile(_p.ref = optarg);    break; }
            case OPT_MIXTURE: { checkFile(_p.mix = optarg);    break; }
            case OPT_OUTPUT:  { checkFile(_p.output = optarg); break; }
            case OPT_FILTER:  { readFilters(optarg);         break; }
            case OPT_MAX:     { parseDouble(optarg, _p.max);   break; }
            case OPT_MIN:     { parseDouble(optarg, _p.min);   break; }
            case OPT_LOS:     { parseDouble(optarg, _p.los);   break; }
            case OPT_THREAD:  { parseInt(optarg, _p.threads);  break; }
            case OPT_PSL_1:   { checkFile(_p.pA = optarg);     break; }
            case OPT_PSL_2:   { checkFile(_p.pB = optarg);     break; }

            case CMD_CMD:
            {
                if (!_cmds.count(std::string(optarg)))
                {
                    //const auto ranges = "rna|var|ladder|fusion|cancer|clinic|meta";
                    //const auto format = boost::format("Invalid value for -%1%. Possibilities are: %2%");
                    //throw InvalidValueError((boost::format(format) % arg % ranges).str());
                }

                _p.cmd = _cmds.at(optarg);
                break;
            }

            default:
            {
                if (_p.mode != 0)
                {
                    throw RepeatOptionError("Mode");
                }
                
                // We'll defer the check later we might not even have the command
                //_p.mode = _modes.at(optarg);

                break;
            }
        }
    }
    
    if (_p.cmd == 0)
    {
        //throw InvalidUsageError();
    }
    else if ((_p.cmd == CMD_TEST || _p.cmd == CMD_VER) && (!_p.output.empty() || _p.mode != 0 || !_p.opt1.empty()))
    {
        //throw InvalidUsageError();
    }
    else
    {
        auto &s = Standard::instance();

        switch (_p.cmd)
        {
            case CMD_VER:  { printVersion();                break; }
            case CMD_TEST: { Catch::Session().run(1, argv); break; }

            case CMD_CANCER:
            {
                std::cout << "Cancer Analysis" << std::endl;
                break;
            }

            case CMD_CLINIC:
            {
                std::cout << "Clinic Analysis" << std::endl;
                break;
            }

            case CMD_FUSION:
            {
                std::cout << "Fusion Analysis" << std::endl;
                
                applyMix(std::bind(&Standard::f_mix, &s, std::placeholders::_1));
                applyRef(std::bind(&Standard::f_ref, &s, std::placeholders::_1));
                
                switch (mode)
                {
                    case MODE_FUSION: { analyze<FFusion>(_p.opt1); break; }
                }

                break;
            }

            case CMD_LADDER:
            {
                std::cout << "Ladder Analysis" << std::endl;

                applyMix(std::bind(&Standard::l_mix, &s, std::placeholders::_1));
                
                extern std::string LadderDataMix();
                    
                switch (mode)
                {
                    case MODE_MIXTURE: { printMixture(LadderDataMix()); break; }
                    case MODE_CORRECT: { analyze<LCorrect>(_p.opt1);      break; }
                    case MODE_DIFFS:   { analyze<LDiffs>(_p.pA, _p.pB);     break; }
                }

                break;
            }
                
            case CMD_RNA:
            {
                std::cout << "RNA Analysis" << std::endl;

                applyMix(std::bind(&Standard::r_mix, &s, std::placeholders::_1));
                applyRef(std::bind(&Standard::r_ref, &s, std::placeholders::_1));
                
                extern std::string RNADataMix();
                
                switch (mode)
                {
                    case MODE_MIXTURE:  { printMixture(RNADataMix()); break; }
                    case MODE_ALIGN:    { analyze<RAlign>(_p.opt1);     break; }
                    case MODE_ASSEMBLY: { analyze<RAssembly>(_p.opt1);  break; }
                    case MODE_ABUNDANCE:
                    {
                        analyze<RAbundance>(_p.opt1, detect<RAbundance::Options>(_p.opt1));
                        break;
                    }

                    case MODE_DIFFS:
                    {
                        analyze<RDiffs>(_p.opt1, detect<RDiffs::Options>(_p.opt1));
                        break;
                    }
                }

                break;
            }

            case CMD_VAR:
            {
                std::cout << "Variant Analysis" << std::endl;
                
                applyMix(std::bind(&Standard::v_mix, &s, std::placeholders::_1));
                applyRef(std::bind(&Standard::v_ref, &s, std::placeholders::_1));
                
                extern std::string DNADataMix();
                
                switch (mode)
                {
                    case MODE_MIXTURE:   { printMixture(DNADataMix()); break; }
                    case MODE_ALIGN:     { analyze<VAlign>(_p.opt1);     break; }
                    case MODE_VARIATION: { analyze<DVariant>(_p.opt1);   break; }
                }

                break;
            }
                
            case CMD_META:
            {
                std::cout << "Metagenomics Analysis" << std::endl;
                
                applyMix(std::bind(&Standard::m_mix, &s, std::placeholders::_1));
                applyRef(std::bind(&Standard::m_ref, &s, std::placeholders::_1));

                extern std::string MetaDataMix();
                
                switch (mode)
                {
                    case MODE_MIXTURE: { printMixture(MetaDataMix()); break; }
                    case MODE_BLAST:   { MBlast::analyze(_p.opt1);      break; }
                        
                    case MODE_DIFFS:
                    {
                        //                            if (_opts.size() != 2 || (!_pA.empty() != !_pB.empty()))
                        {
                            //throw InvalidUsageError();
                        }
                        
                        MDiffs::Options o;
                        
                        o.pA = _p.pA;
                        o.pB = _p.pB;
                        
                        analyze<MDiffs>(_p.pA, _p.pB, o);
                        break;
                    }
                        
                    case MODE_ASSEMBLY:
                    {
                        MAssembly::Options o;
                        
                        // We'd also take an alignment PSL file from a user
                        o.psl = _p.pA;
                        
                        analyze<MAssembly>(_p.opt1, o);
                        break;
                    }
                }
                
                break;
            }
                
            default:
            {
                assert(false);
            }
        }
    }
}

int parse_options(int argc, char ** argv)
{
    auto printError = [&](const std::string &file)
    {
        std::cerr << std::endl;
        std::cerr << "*********************************************" << std::endl;
        std::cerr << file << std::endl;
        std::cerr << "*********************************************" << std::endl;
    };
    
    try
    {
        parse(argc, argv);
        return 0;
    }
    catch (const EmptyFileError &ex)
    {
        printError((boost::format("%1%%2%") % "Empty file: " % ex.what()).str());
    }
    catch (const InvalidFileError &ex)
    {
        printError((boost::format("%1%%2%") % "Invalid file: " % ex.what()).str());
    }
    catch (const InvalidFilterError &ex)
    {
        printError((boost::format("%1%%2%") % "Invalid filter: " % ex.what()).str());
    }

    return 1;
}

int main(int argc, char ** argv)
{
#ifndef DEBUG
    signal(SIGSEGV, handler);
#endif
    return parse_options(argc, argv);
}