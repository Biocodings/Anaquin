#include <map>
#include <ctime>
#include <iostream>
#include <unistd.h>
#include <getopt.h>
#include <execinfo.h>

#include "data/tokens.hpp"
#include "data/reader.hpp"

#include "rna/r_diffs.hpp"
#include "rna/r_align.hpp"
#include "rna/r_assembly.hpp"
#include "rna/r_abundance.hpp"

#include "var/v_align.hpp"
#include "var/v_variant.hpp"

#include "meta/m_blast.hpp"
#include "meta/m_diffs.hpp"
#include "meta/m_assembly.hpp"

#include "ladder/l_diffs.hpp"
#include "ladder/l_correct.hpp"

#include "fusion/f_fusion.hpp"

#include "parsers/parser_csv.hpp"
#include "parsers/parser_sequins.hpp"

#include "writers/file_writer.hpp"
#include "writers/terminal_writer.hpp"

#define CATCH_CONFIG_RUNNER
#include <catch.hpp>

typedef int Mode;
typedef int Command;

#define CMD_CMD    'c'
#define CMD_VER    'v'
#define CMD_TEST   't'
#define CMD_RNA    265
#define CMD_VAR    266
#define CMD_META   267
#define CMD_LADDER 268
#define CMD_FUSION 269
#define CMD_FETAL  270
#define CMD_CANCER 271
#define CMD_STRUCT 272
#define CMD_CLINIC 273

#define MODE_BLAST     281
#define MODE_ALIGN     283
#define MODE_ASSEMBLY  284
#define MODE_ABUNDANCE 285
#define MODE_DIFFS     286
#define MODE_VARIATION 287
#define MODE_CORRECT   289
#define MODE_MIXTURE   290
#define MODE_FUSION    291

#define OPT_MIN     321
#define OPT_MAX     322
#define OPT_LOS     323
#define OPT_OUTPUT  324
#define OPT_REF     325
#define OPT_MIXTURE 326
#define OPT_FILTER  327
#define OPT_THREAD  328
#define OPT_MODE    329
#define OPT_PSL_1   330
#define OPT_PSL_2   331

using namespace Spike;

void handler(int sig)
{
    void *array[10];
    size_t size;
    
    // get void*'s for all entries on the stack
    size = backtrace(array, 10);
    
    // print out all the frames to stderr
    fprintf(stderr, "Error: signal %d:\n", sig);
    backtrace_symbols_fd(array, size, STDERR_FILENO);
    exit(1);
}

// For example, giving "ABCD" as the number of threads
struct InvalidFormatError : public std::runtime_error
{
    InvalidFormatError(const std::string &msg) : std::runtime_error(msg) {}
};

// Giving the same option more than once
struct RepeatOptionError : public std::runtime_error
{
    RepeatOptionError(const std::string &msg) : std::runtime_error(msg) {}
};

// The value of the option is invalid
struct InvalidValueError : public std::runtime_error
{
    InvalidValueError(const std::string &msg) : std::runtime_error(msg) {}
};

struct InvalidUsageError : public std::runtime_error
{
    InvalidUsageError(const std::string &msg) : std::runtime_error(msg) {}
};

struct InvalidFilterError : public std::runtime_error
{
    InvalidFilterError(const std::string &msg) : std::runtime_error(msg) {}
};

/*
 * Variables used in argument parsing
 */

// The path that output files are written
static std::string _output;

// PSL alignment for the mixture A generated by BLAST
static std::string _pA;

// PSL alignment for the mixtuee B generated by BLAST
static std::string _pB;

// Number of threads
static unsigned _threads = 1;

// Custom minmium concentration
static double _min;

// Custom maximum concentration
static double _max;

// Custom sensivitiy
static double _los;

// Custom reference file
static std::string _ref;

// Custom mixture file
static std::string _mix;

// The sequins that have been filtered
static std::set<SequinID> _filters;

static int _cmd  = 0;
static int _mode = 0;

// The first operand for the command
std::string _opt1;

// The second operand for the command
std::string _opt2;

/*
 * Defines the possible command values
 */

static std::map<std::string, Command> _cmds =
{
    { "rna",    CMD_RNA    },
    { "var",    CMD_VAR    },
    { "meta",   CMD_META   },
    { "ladder", CMD_LADDER },
    { "cancer", CMD_CANCER },
    { "fusion", CMD_FUSION },
    { "clinic", CMD_CLINIC },
};

/*
 * Define the possible modes for each command
 */

static std::map<std::string, Mode> _modes =
{
    { "correct",   MODE_CORRECT   },
    { "abundance", MODE_ABUNDANCE },
    { "align",     MODE_ALIGN     },
    { "diffs",     MODE_DIFFS },
};

static void reset()
{
    _pA.clear();
    _pB.clear();
    _mix.clear();
    _ref.clear();
    _output.clear();
    _filters.clear();
    _opt1.clear();
    _opt2.clear();
    _cmd = _mode = 0;
}

/*
 * Argument options
 */

static const char *short_options = "";

static const struct option long_options[] =
{
    { "v",      no_argument, 0, CMD_VER  },
    { "verson", no_argument, 0, CMD_VER  },
    { "t",      no_argument, 0, CMD_TEST },
    { "test",   no_argument, 0, CMD_TEST },

    { "c",       required_argument, 0, CMD_CMD },
    { "command", required_argument, 0, CMD_CMD },

    { "min",     required_argument, 0, OPT_MIN },
    { "max",     required_argument, 0, OPT_MAX },

    { "p1",      required_argument, 0, OPT_PSL_1 },
    { "p2",      required_argument, 0, OPT_PSL_2 },

    { "los",     required_argument, 0, OPT_LOS },

    { "r",       required_argument, 0, OPT_REF },
    { "ref",     required_argument, 0, OPT_REF },

    { "t",       required_argument, 0, OPT_THREAD },
    { "threads", required_argument, 0, OPT_THREAD },

    { "m",       required_argument, 0, OPT_MIXTURE },
    { "mix",     required_argument, 0, OPT_MIXTURE },
    { "mixture", required_argument, 0, OPT_MIXTURE },

    { "p",       required_argument, 0, OPT_MODE },
    { "mode",    required_argument, 0, OPT_MODE },

    { "o",       required_argument, 0, OPT_OUTPUT  },
    { "output",  required_argument, 0, OPT_OUTPUT  },

    { "f",        required_argument, 0, OPT_FILTER },
    { "filter",   required_argument, 0, OPT_FILTER },

    { "blast", required_argument, 0, MODE_BLAST },

    {0, 0, 0, 0 }
};

static void printUsage()
{
    extern std::string Manual();
    std::cout << Manual() << std::endl;
}

static void printVersion()
{
    extern float ChromoVersion();
    extern float MixtureVersion();

    // Most likely it's chrT
    extern FileName ChromoName();
    
    std::cout << "Version 1.0. Garvan Institute of Medical Research, 2015." << std::endl;
    std::cout << std::endl;
    std::cout << "Chromosome: " << ChromoName() << " version " << ChromoVersion() << std::endl;
    std::cout << "Mixture: version " << MixtureVersion() << std::endl;
}

// Print a file of mixture A and B
void print(Reader &r)
{
    /*
     * Format: <ID, Mix A, Mix B>
     */

    std::string l;
    
    // Skip the first line
    r.nextLine(l);

    std::cout << "ID\tMix A\tMix B" << std::endl;

    while (r.nextLine(l))
    {
        if (l == "\r" || l == "\n" || l == "\r\n")
        {
            continue;
        }

        std::vector<std::string> tokens;
        Tokens::split(l, "\t", tokens);

        std::cout << tokens[0] << "\t" << tokens[2] << "\t" << tokens[3] << std::endl;
    }
}

static void printMixture(const std::string &file)
{
    Reader r(file, String);
    print(r);
}

static void printFeatures(const Standard::SequinMap &m)
{
    for (const auto &i : m)
    {
        std::cout << i.first << " " << i.second.l.start << " " << i.second.l.end << std::endl;
    }
}

template <typename Mixture, typename Model> void applyCustom(Mixture mix, Model mod)
{
    if (_mix.empty() && _ref.empty())
    {
        return;
    }
    else if ((!_mix.empty() && _ref.empty()) || (_mix.empty() && !_ref.empty()))
    {
        //throw InvalidUsageError();
    }

    std::cout << "Mixture file: "   << _mix << std::endl;
    std::cout << "Reference file: " << _ref << std::endl;

    mix(Reader(_mix));
    mod(Reader(_ref));
}

// Read sequins from a file, one per line. The identifiers must match.
static void readFilters(const std::string &file)
{
    Reader r(file);
    std::string line;
    
    // We'll use it to compare the sequins
    const auto &s = Standard::instance();

    while (r.nextLine(line))
    {
        switch (_cmd)
        {
            case CMD_FUSION: { break; }
            case CMD_LADDER: { break; }

            case CMD_RNA:
            {
                assert(s.r_seqs_A.size() == s.r_seqs_B.size());

                if (!s.r_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for RNA: " + line);
                }
                
                _filters.insert(line);
                break;
            }

            case CMD_VAR:
            {
                assert(s.d_seqs_A.size() == s.d_seqs_B.size());
                
                if (!s.d_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for DNA: " + line);
                }
                
                _filters.insert(line);
                break;
            }

            case CMD_META:
            {
                assert(s.m_seqs_A.size() == s.m_seqs_B.size());

                if (!s.m_seqs_A.count(line))
                {
                    throw InvalidFilterError("Unknown sequin for metagenomics: " + line);
                }

                _filters.insert(line);
                break;
            }

            //default: { throw InvalidUsageError(); }
        }
    }

    if (_filters.empty())
    {
        throw InvalidFilterError("No sequin found in: " + file);
    }
}

template <typename Analyzer, typename F> void analyzeF(F f, typename Analyzer::Options o)
{
    const auto path = _output.empty() ? "spike_out" : _output;
    
    std::cout << "Path: " << path << std::endl;

#ifndef DEBUG
    o.writer   = std::shared_ptr<FileWriter>(new FileWriter(path));
    o.logger   = std::shared_ptr<FileWriter>(new FileWriter(path));
    o.terminal = std::shared_ptr<TerminalWriter>(new TerminalWriter());
    o.logger->open("anaquin.log");
#endif

    std::cout << "-----------------------------------------" << std::endl;
    std::cout << "------------- Sequin Analysis -----------" << std::endl;
    std::cout << "-----------------------------------------" << std::endl << std::endl;
    
    for (const auto &filter : (o.filters = _filters))
    {
        std::cout << "Filter: " << filter << std::endl;
    }
    
    std::clock_t begin = std::clock();
    
    f(o);
    
    std::clock_t end = std::clock();
    const double elapsed = double(end - begin) / CLOCKS_PER_SEC;
    std::cout << "Completed. Elpased: " << elapsed << " seconds" << std::endl;

#ifndef DEBUG
    o.logger->close();
#endif
}

// Analyze for a single-sample input
template <typename Analyzer> void analyze(const std::string &file, typename Analyzer::Options o = typename Analyzer::Options())
{
    return analyzeF<Analyzer>([&](const typename Analyzer::Options &o) { Analyzer::analyze(file, o); }, o);
}

// Analyze for two-samples input
template <typename Analyzer> void analyze(const std::string &f1, const std::string &f2, typename Analyzer::Options o = typename Analyzer::Options())
{
    return analyzeF<Analyzer>([&](const typename Analyzer::Options &o) { Analyzer::analyze(f1, f2, o); }, o);
}

template <typename Options> static Options detect(const std::string &file)
{
    const bool found_gene = file.find("gene") != std::string::npos;
    const bool found_isoform = file.find("isoform") != std::string::npos;

    Options o;
    
    if (found_gene && !found_isoform)
    {
        std::cout << "Calculating for the genes" << std::endl;
        o.level = RNALevel::Gene;
    }
    else if (!found_gene && found_isoform)
    {
        std::cout << "Calcualting for the isoforms" << std::endl;
        o.level = RNALevel::Isoform;
    }
    else
    {
        throw std::runtime_error("Unknown type. Have you specified the level?");
    }

    return o;
}

void parse(int argc, char ** argv)
{
    reset();

    if (argc <= 1)
    {
        printUsage();
    }

    int next, index;

#ifdef UNIT_TESTING
    optind = optreset = 1;
#endif

    /*
     * Reconstruct the overall command
     */
    
    std::string command;
    
    for (int i = 0; i < argc; i++)
    {
        command += std::string(argv[i]) + " ";
    }

    assert(!command.empty());

    // Attempt to parse and store a floating point from string
    auto parseDouble = [&](const std::string &str, double &r)
    {
        assert(next);
        
        try
        {
            r = stof(str);
        }
        catch (...)
        {
            throw std::runtime_error("ddddd");
        }
    };
    
    // Attempt to parse and store an integer from string
    auto parseInt = [&](const std::string &str, unsigned &r)
    {
        assert(next);
        
        try
        {
            r = stoi(str);
        }
        catch (...)
        {
            throw std::runtime_error("eeee");
        }
    };
    
    auto checkFile = [&](const std::string &file)
    {
        if (!std::ifstream(file).good())
        {
            throw InvalidFileError(file);
        }
    };

    while ((next = getopt_long_only(argc, argv, short_options, long_options, &index)) != -1)
    {
        const auto &arg = argv[index];

        switch (next)
        {
            case OPT_REF:     { checkFile(_ref = optarg);    break; }
            case OPT_MIXTURE: { checkFile(_mix = optarg);    break; }
            case OPT_OUTPUT:  { checkFile(_output = optarg); break; }
            case OPT_FILTER:  { readFilters(optarg);         break; }
            case OPT_MAX:     { parseDouble(optarg, _max);   break; }
            case OPT_MIN:     { parseDouble(optarg, _min);   break; }
            case OPT_LOS:     { parseDouble(optarg, _los);   break; }
            case OPT_THREAD:  { parseInt(optarg, _threads);  break; }
            case OPT_PSL_1:   { checkFile(_pA = optarg);     break; }
            case OPT_PSL_2:   { checkFile(_pB = optarg);     break; }

            case CMD_CMD:
            {
                if (!_cmds.count(std::string(optarg)))
                {
                    const auto ranges = "rna|var|ladder|fusion|cancer|clinic|meta";
                    const auto format = boost::format("Invalid value for -%1%. Possibilities are: %2%");
                    throw InvalidValueError((boost::format(format) % arg % ranges).str());
                }

                _cmd = _cmds.at(optarg);
                break;
            }

            default:
            {
                if (_mode != 0)
                {
                    throw RepeatOptionError("Mode");
                }
                
                // We'll defer the check later we might not even have the command
                _mode = _modes.at(optarg);

                break;
            }
        }
    }
    
    if (_cmd == 0)
    {
        //throw InvalidUsageError();
    }
    else if ((_cmd == CMD_TEST || _cmd == CMD_VER) && (!_output.empty() || _mode != 0 || !_opt1.empty()))
    {
        //throw InvalidUsageError();
    }
    else
    {
        auto &s = Standard::instance();

        switch (_cmd)
        {
            case CMD_VER:  { printVersion();                break; }
            case CMD_TEST: { Catch::Session().run(1, argv); break; }

            case CMD_CANCER:
            {
                std::cout << "Cancer Analysis" << std::endl;
                break;
            }

            case CMD_CLINIC:
            {
                std::cout << "Clinic Analysis" << std::endl;
                break;
            }

            case CMD_FUSION:
            {
                std::cout << "Fusion Analysis" << std::endl;

                if (_mode != MODE_FUSION)
                {
                    //throw InvalidUsageError();
                }
                else
                {
                    switch (_mode)
                    {
                        case MODE_FUSION: { analyze<FFusion>(_opt1); break; }
                    }
                }

                break;
            }

            case CMD_LADDER:
            {
                std::cout << "Ladder Analysis" << std::endl;

                if (_mode != MODE_MIXTURE &&
                    _mode != MODE_CORRECT &&
                    _mode != MODE_DIFFS)
                {
                    //throw InvalidUsageError();
                }
                else
                {
                    extern std::string LadderDataMix();
                    
                    switch (_mode)
                    {
                        case MODE_MIXTURE: { printMixture(LadderDataMix()); break; }
                        case MODE_CORRECT: { analyze<LCorrect>(_opt1);      break; }
                        case MODE_DIFFS:   { analyze<LDiffs>(_pA, _pB);     break; }
                    }
                }

                break;
            }
                
            case CMD_RNA:
            {
                std::cout << "RNA Analysis" << std::endl;

                applyCustom(std::bind(&Standard::rna_mix, &s, std::placeholders::_1),
                            std::bind(&Standard::rna_mod, &s, std::placeholders::_1));

                if (_mode != MODE_MIXTURE   &&
                    _mode != MODE_ALIGN     &&
                    _mode != MODE_ASSEMBLY  &&
                    _mode != MODE_ABUNDANCE &&
                    _mode != MODE_DIFFS)
                {
                    //throw InvalidUsageError();
                }
                else
                {
                    extern std::string RNADataMix();
                    
                    switch (_mode)
                    {
                        case MODE_MIXTURE:  { printMixture(RNADataMix()); break; }
                        case MODE_ALIGN:    { analyze<RAlign>(_opt1);     break; }
                        case MODE_ASSEMBLY: { analyze<RAssembly>(_opt1);  break; }
                            
                        case MODE_ABUNDANCE:
                        {
                            analyze<RAbundance>(_opt1, detect<RAbundance::Options>(_opt1));
                            break;
                        }

                        case MODE_DIFFS:
                        {
                            analyze<RDiffs>(_opt1, detect<RDiffs::Options>(_opt1));
                            break;
                        }
                    }
                }
                
                break;
            }

            case CMD_VAR:
            {
                std::cout << "Variant Analysis" << std::endl;
                
                applyCustom(std::bind(&Standard::dna_mix, &s, std::placeholders::_1),
                            std::bind(&Standard::dna_mod, &s, std::placeholders::_1));
                
                if (_mode != MODE_MIXTURE  &&
                    _mode != MODE_ALIGN    &&
                    _mode != MODE_VARIATION)
                {
                    //throw InvalidUsageError();
                }
                else
                {
                    extern std::string DNADataMix();
                    
                    switch (_mode)
                    {
                        case MODE_MIXTURE:   { printMixture(DNADataMix()); break; }
                        case MODE_ALIGN:     { analyze<VAlign>(_opt1);     break; }
                        case MODE_VARIATION: { analyze<DVariant>(_opt1);   break; }
                    }
                }

                break;
            }
                
            case CMD_META:
            {
                std::cout << "Metagenomics Analysis" << std::endl;
                
                applyCustom(std::bind(&Standard::meta_mix, &s, std::placeholders::_1),
                            std::bind(&Standard::meta_mod, &s, std::placeholders::_1));

                if (_mode != MODE_BLAST    &&
                    _mode != MODE_MIXTURE  &&
                    _mode != MODE_ASSEMBLY &&
                    _mode != MODE_DIFFS)
                {
                    //throw InvalidUsageError();
                }
                else
                {
                    extern std::string MetaDataMix();

                    switch (_mode)
                    {
                        case MODE_MIXTURE: { printMixture(MetaDataMix()); break; }
                        case MODE_BLAST:   { MBlast::analyze(_opt1);      break; }

                        case MODE_DIFFS:
                        {
//                            if (_opts.size() != 2 || (!_pA.empty() != !_pB.empty()))
                            {
                                //throw InvalidUsageError();
                            }

                            MDiffs::Options o;

                            o.pA = _pA;
                            o.pB = _pB;

                            analyze<MDiffs>(_pA, _pB, o);
                            break;
                        }

                        case MODE_ASSEMBLY:
                        {
                            MAssembly::Options o;
                            
                            // We'd also take an alignment PSL file from a user
                            o.psl = _pA;

                            analyze<MAssembly>(_opt1, o);
                            break;
                        }
                    }
                }
                
                break;
            }
                
            default:
            {
                assert(false);
            }
        }
    }
}

int parse_options(int argc, char ** argv)
{
    auto printError = [&](const std::string &file)
    {
        std::cerr << std::endl;
        std::cerr << "*********************************************" << std::endl;
        std::cerr << file << std::endl;
        std::cerr << "*********************************************" << std::endl;
    };
    
    try
    {
        parse(argc, argv);
        return 0;
    }
    catch (const EmptyFileError &ex)
    {
        printError((boost::format("%1%%2%") % "Empty file: " % ex.what()).str());
    }
    catch (const InvalidFileError &ex)
    {
        printError((boost::format("%1%%2%") % "Invalid file: " % ex.what()).str());
    }
    catch (const InvalidUsageError &)
    {
        printUsage();
    }
    catch (const InvalidFilterError &ex)
    {
        printError((boost::format("%1%%2%") % "Invalid filter: " % ex.what()).str());
    }

    return 1;
}

int main(int argc, char ** argv)
{
#ifndef DEBUG
    signal(SIGSEGV, handler);
#endif
    return parse_options(argc, argv);
}